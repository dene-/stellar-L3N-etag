<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Electronic Shelf Label Bluetooth Controller</title>
    <style>
      #tool-box > * {
        margin-right: 5px;
      }

      * {
        padding: 0;
        margin: 0;
      }

      button,
      a {
        padding: 2px;
        margin: 2px;
        display: inline-block;
      }

      body {
        padding: 20px;
        overflow-y: hidden;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/rgbquant/src/rgbquant.min.js"></script>
    <script type="application/javascript" src="js/dithering.js"></script>
    <script type="application/javascript" src="js/utils.js"></script>
  </head>

  <body>
    <script>
      let bleDevice;
      let gattServer;
      let epdService;
      let rxtxService;
      let epdCharacteristic;
      let rxtxCharacteristic;
      let reconnectTrys = 0;
      // Pristine copy of the last loaded image (canvas-sized) for re-dithering
      let gOriginalImageData = null;

      function delay(delayInms) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(2);
          }, delayInms);
        });
      }

      function resetVariables() {
        gattServer = null;
        epdService = null;
        epdCharacteristic = null;
        rxtxCharacteristic = null;
        rxtxService = null;
        document.getElementById("log").value = "";
      }

      async function handleError(error) {
        console.log(error);
        resetVariables();
        if (bleDevice == null) return;
        if (reconnectTrys <= 5) {
          reconnectTrys++;
          await connect();
        } else {
          addLog("Was not able to connect, aborting");
          reconnectTrys = 0;
        }
      }

      async function sendCommand(cmd) {
        if (epdCharacteristic) {
          await epdCharacteristic.writeValueWithResponse(cmd);
        } else {
          addLog("Service unavailable. Is Bluetooth connected?");
        }
      }

      async function clearScreen(cmd) {
        addLog("Clear screen");
        await triggerEpdCmd(`00${cmd}`);
        await triggerEpdCmd("01");
      }

      async function rxTxSendCommand(cmd) {
        if (rxtxCharacteristic) {
          await rxtxCharacteristic.writeValueWithResponse(cmd);
        } else {
          addLog("Service unavailable. Is Bluetooth connected?");
        }
      }

      async function upload_tiff_image() {
        const startTime = new Date().getTime();
        const buffer = await document
          .getElementById("tiff_file")
          .files[0].arrayBuffer();
        const arr = bytesToHex(buffer);

        addLog(`Start uploading TIFF, size ${arr.length / 1024} KB`);

        await sendCommand(hexToBytes("0000"));

        await sendCommand(hexToBytes("020000"));

        const step = 480;
        let partIndex = 0;
        for (let i = 0; i < arr.length; i += step) {
          addLog(
            `Uploading block ${partIndex + 1}. Block size: ${step + 1} bytes`
          );
          await sendCommand(hexToBytes("03" + arr.slice(i, i + step)));
          partIndex += 1;
        }

        await sendCommand(hexToBytes("04"));
        addLog(
          `TIFF upload completed, took ${
            (new Date().getTime() - startTime) / 1000
          }s`
        );
      }

      async function sendBufferData(value, type) {
        addLog(
          `Start sending image mode: ${type}, size ${
            value.length / 2 / 1024
          } KB`
        );
        let code = "ff";
        if (type === "bwr") {
          code = "00";
        }
        const step = 480;
        let partIndex = 0;
        for (let i = 0; i < value.length; i += step) {
          addLog(
            `Sending block ${partIndex + 1}. Block size: ${
              step / 2 + 4
            } bytes. Offset: ${i / 2}`
          );
          await sendCommand(
            hexToBytes(
              "03" + code + intToHex(i / 2, 2) + value.substring(i, i + step)
            )
          );
          partIndex += 1;
        }
      }

      async function upload_image() {
        const canvas = document.getElementById("canvas");

        const startTime = new Date().getTime();

        await sendCommand(hexToBytes("0000"));

        await sendCommand(hexToBytes("020000"));

        await sendBufferData(bytesToHex(canvas2bytes(canvas)), "bw");
        await sendBufferData(bytesToHex(canvas2bytes(canvas, "bwr")), "bwr");

        await sendCommand(hexToBytes("0101"));

        addLog(
          `Refresh done, took ${(new Date().getTime() - startTime) / 1000}s`
        );
      }

      async function upload_epd_buffer() {
        const startTime = new Date().getTime();
        const value = document
          .getElementById("buffer")
          .value.replace(/(?:\r\n|\r|\n|,|0x| )/g, "");

        addLog(`Start updating display buffer, size ${value.length / 1024} KB`);

        await sendCommand(hexToBytes("0000"));

        await sendCommand(hexToBytes("020000"));

        await sendBufferData(value, "bw");

        await delay(150);

        await sendCommand(hexToBytes("0101"));

        addLog(
          `Refresh done, took ${(new Date().getTime() - startTime) / 1000}s`
        );
      }

      async function setTime() {
        const { unixNow, localeTimeString, year, month, day, week } =
          getUnixTime();

        addLog(
          "Time set to: " + localeTimeString + " : dd" + intToHex(unixNow, 4)
        );
        await rxTxSendCommand(
          hexToBytes(
            "dd" +
              [
                intToHex(unixNow, 4),
                intToHex(year, 2),
                intToHex(month, 1),
                intToHex(day, 1),
                intToHex(week, 1),
              ].join("")
          )
        );

        await rxTxSendCommand(hexToBytes("e2"));
      }

      async function triggerRxTxCmd(cmd) {
        addLog(`Send command: ${cmd}`);
        await rxTxSendCommand(hexToBytes(cmd));
      }

      async function triggerEpdCmd(cmd) {
        addLog(`Send command: ${cmd}`);
        await sendCommand(hexToBytes(cmd));
      }

      function disconnect() {
        resetVariables();
        addLog("Disconnected.");
        document.getElementById("connectbutton").innerHTML = "Connect";
      }

      async function preConnect() {
        if (gattServer != null && gattServer.connected) {
          if (bleDevice != null && bleDevice.gatt.connected)
            bleDevice.gatt.disconnect();
        } else {
          reconnectTrys = 0;
          bleDevice = await navigator.bluetooth.requestDevice({
            optionalServices: [
              "0000221f-0000-1000-8000-00805f9b34fb",
              "00001f10-0000-1000-8000-00805f9b34fb",
              "13187b10-eba9-a3ba-044e-83d3217d9a38",
            ],
            acceptAllDevices: true,
          });
          await bleDevice.addEventListener(
            "gattserverdisconnected",
            disconnect
          );
          try {
            await connect();
          } catch (e) {
            await handleError(e);
          }
        }
      }

      async function connectRXTX() {
        rxtxService = await gattServer.getPrimaryService(
          "00001f10-0000-1000-8000-00805f9b34fb"
        );
        addLog("> Found UART service");

        rxtxCharacteristic = await rxtxService.getCharacteristic(
          "00001f1f-0000-1000-8000-00805f9b34fb"
        );
        addLog("> UART service connected");
      }

      async function reConnect() {
        connectTrys = 0;
        if (bleDevice != null && bleDevice.gatt.connected)
          bleDevice.gatt.disconnect();
        resetVariables();
        addLog("Reconnecting");
        setTimeout(async function () {
          await connect();
        }, 300);
      }

      async function connect() {
        if (epdCharacteristic == null) {
          addLog("Connecting to: " + bleDevice.name);

          gattServer = await bleDevice.gatt.connect();
          addLog("> Found GATT server");

          epdService = await gattServer.getPrimaryService(
            "13187b10-eba9-a3ba-044e-83d3217d9a38"
          );
          addLog("> Found service");

          epdCharacteristic = await epdService.getCharacteristic(
            "4b646063-6264-f3a7-8941-e65356ea82fe"
          );
          addLog("> Service connected");

          await epdCharacteristic.startNotifications();

          epdCharacteristic.addEventListener(
            "characteristicvaluechanged",
            (event) => {
              console.log("epd ret", bytesToHex(event.target.value.buffer));
              const count = parseInt(
                "0x" + bytesToHex(event.target.value.buffer)
              );
              addLog(`> [From display]: Received ${count} bytes`);
            }
          );

          document.getElementById("connectbutton").innerHTML = "Disconnect";
          await connectRXTX();
        }
      }

      function setStatus(statusText) {
        document.getElementById("status").innerHTML = statusText;
      }

      function addLog(logTXT) {
        const today = new Date();
        const time =
          ("0" + today.getHours()).slice(-2) +
          ":" +
          ("0" + today.getMinutes()).slice(-2) +
          ":" +
          ("0" + today.getSeconds()).slice(-2) +
          " : ";

        const dom = document.getElementById("log");

        dom.innerHTML += time + logTXT + "<br>";
        dom.scrollTop = dom.scrollHeight;
      }

      function getUnixTime() {
        const hourOffset = document.getElementById("hour-offset").value;
        const unixNow =
          Math.round(Date.now() / 1000) +
          60 * 60 * hourOffset -
          new Date().getTimezoneOffset() * 60;

        const date = new Date(
          (unixNow + new Date().getTimezoneOffset() * 60) * 1000
        );
        const localeTimeString = date.toLocaleTimeString();

        return {
          unixNow,
          localeTimeString,
          year: date.getFullYear(),
          month: date.getMonth() + 1,
          day: date.getDate(),
          week: date.getDay() || 7,
        };
      }

      async function update_image() {
        const image_file = document.getElementById("image_file");
        if (image_file.files.length > 0) {
          const file = image_file.files[0];

          const canvas = document.getElementById("canvas");
          const ctx = canvas.getContext("2d");

          const image = new Image();
          image.src = URL.createObjectURL(file);
          image.onload = function (event) {
            URL.revokeObjectURL(this.src);
            ctx.drawImage(
              image,
              0,
              0,
              image.width,
              image.height,
              0,
              0,
              canvas.width,
              canvas.height
            );
            // Snapshot original pixels so mode switches restart from source
            gOriginalImageData = ctx.getImageData(
              0,
              0,
              canvas.width,
              canvas.height
            );
            convert_dithering();
          };
        }
      }

      function get_position(canvas, x, y) {
        let rect = canvas.getBoundingClientRect();
        return {
          x: x - rect.left * (canvas.width / rect.width),
          y: y - rect.top * (canvas.height / rect.height),
        };
      }

      function clear_canvas() {
        if (confirm("Clear canvas?")) {
          const canvas = document.getElementById("canvas");
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      function convert_dithering() {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const mode = document.getElementById("dithering").value;
        // Always re-render from the original image if available
        if (gOriginalImageData) {
          ctx.putImageData(gOriginalImageData, 0, 0);
        }

        const serp = document.getElementById("dithSerp")
          ? document.getElementById("dithSerp").checked
          : false;

        console.log(serp);

        // RgbQuant-powered modes use prefixes bw_/bwr_
        const isBwr = mode.startsWith("bwr_");
        const palette = isBwr ? bwrPalette : bwPalette;
        const kern = mode.split("_")[1];
        const opts = { dithSerp: serp };

        ditheringCanvasByPalette(canvas, palette, kern, opts);
      }

      document.body.onload = () => {
        setInterval(() => {
          const { localeTimeString, year, month, day, week } = getUnixTime();
          document.getElementById(
            "time-setter"
          ).innerText = `Set time to: ${year}-${month}-${day} ${localeTimeString} Weekday ${week}`;
        }, 1000);

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let is_allow_drawing = false;
        let is_allow_move_editor = false;
        const image_mode = document.getElementById("canvas-mode");
        const paint_size = document.getElementById("paint-size");
        const paint_color = document.getElementById("paint-color");
        const editor = document.getElementById("edit-font");
        const font = document.getElementById("font");
        document.getElementById("dithering").value = "bwr_Atkinson";
        // Re-apply dithering on UI changes
        document
          .getElementById("dithering")
          .addEventListener("change", convert_dithering);
        const serpCk = document.getElementById("dithSerp");
        if (serpCk) serpCk.addEventListener("change", convert_dithering);
        const thr = document.getElementById("threshold");
        if (thr) thr.addEventListener("change", convert_dithering);
        image_mode.value = "paint";
        paint_color.value = "black";
        font.value = "黑体";

        editor.onmousemove = function (e) {
          editor.style.fontSize = `${paint_size.value * 10}px`;
          editor.style.color = paint_color.value;
          editor.style.fontFamily = font.value;
          editor.style.fontWeight = "bold";

          if (is_allow_move_editor) {
            const { x, y } = get_position(canvas, e.clientX, e.clientY);
            if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {
              return;
            }

            editor.style.left = `${e.clientX - 20}px`;
            editor.style.top = `${e.clientY - 20}px`;
          }
        };

        editor.onmousedown = function (e) {
          is_allow_move_editor = true;
        };

        editor.onmouseup = function (e) {
          is_allow_move_editor = false;
        };

        document.getElementById("update-text").onclick = function () {
          if (!editor.value.length) {
            alert("Please enter text");
            return;
          }
          editor.style.display = "none";
          ctx.beginPath();
          ctx.font = `bold ${paint_size.value * 10}px ${font.value}`;
          ctx.fillStyle = paint_color.value;
          const { x, y } = get_position(
            canvas,
            parseInt(editor.style.left),
            parseInt(editor.style.top) + paint_size.value * 10
          );

          ctx.fillText(editor.value, x, y);
        };

        image_mode.onchange = function (e) {
          if (image_mode.value === "font") {
            document.getElementById("update-text").style.display =
              "inline-block";
            document.getElementById("font").style.display = "inline-block";

            editor.style.display = "block";
            editor.style.left = `${e.clientX}px`;
            editor.style.top = `${e.clientY}px`;
            return;
          }
          document.getElementById("update-text").style.display = "none";
          document.getElementById("font").style.display = "none";
          editor.style.display = "none";
        };

        paint_size.onchange = function () {
          if (image_mode.value === "font") {
            editor.style.fontSize = `${paint_size.value * 10}px`;
          }
        };

        paint_color.onchange = function () {
          if (image_mode.value === "font") {
            editor.style.color = paint_color.value;
          }
        };

        font.onchange = function () {
          if (image_mode.value === "font") {
            editor.style.fontFamily = font.value;
          }
        };

        canvas.onmousedown = function (e) {
          let ele = get_position(canvas, e.clientX, e.clientY);
          let { x, y } = ele;

          switch (image_mode.value) {
            case "paint":
              is_allow_drawing = true;
              ctx.beginPath();
              ctx.moveTo(x, y);
              break;
            case "font":
              editor.style.display = "block";
              editor.style.left = `${e.clientX}px`;
              editor.style.top = `${e.clientY}px`;
              editor.style.fontSize = `${paint_size.value * 10}px`;
              editor.style.color = paint_color.value;
              editor.style.fontFamily = font.value;
              editor.style.fontWeight = "bold";

              break;
            default:
              break;
          }
        };

        canvas.onmousemove = (e) => {
          let ele = get_position(canvas, e.clientX, e.clientY);
          let { x, y } = ele;
          switch (image_mode.value) {
            case "paint":
              if (is_allow_drawing) {
                ctx.lineWidth = paint_size.value;
                ctx.strokeStyle = paint_color.value;
                ctx.lineTo(x, y);
                ctx.stroke();
              }
              break;
            case "font":
              break;

            default:
              break;
          }
        };

        canvas.onmouseup = function () {
          switch (image_mode.value) {
            case "paint":
              is_allow_drawing = false;
              break;

            case "font":
              editor.focus();
              is_allow_move_editor = false;
              break;

            default:
              break;
          }
        };

        canvas.onmouseleave = function () {
          if (image_mode.value === "paint") {
            is_allow_drawing = false;
          }
        };
      };
    </script>
    <h2>
      Electronic Shelf Label Bluetooth Controller
      <a style="margin-left: 130px" href="uart_flasher.html"> UART Flasher </a>
      <a href="ATC_TLSR_PaperBLEcontrol.html">BLE OTA Upgrade</a>
      <a href="weather.html">Weather Station Tool</a>
    </h2>

    <button id="connectbutton" type="button" onclick="preConnect();">
      Connect
    </button>
    <button type="button" onclick="reConnect();">Reconnect</button>
    <button
      type="button"
      onclick="document.getElementById('log').innerHTML = '';"
    >
      Clear log
    </button>
    <br /><br />

    <h3>Commands</h3>
    <input type="text" id="cmdTXT" value="0055" />
    <button
      type="button"
      onclick="triggerEpdCmd(document.getElementById('cmdTXT').value);"
    >
      Send Command
    </button>
    <br />
    <button
      type="button"
      onclick="triggerRxTxCmd('e100')"
      title="Click this button, then upload an image. The image will be permanently displayed on the screen"
    >
      Set Image Mode
    </button>
    <button
      type="button"
      onclick="triggerRxTxCmd('e101')"
      title="Click this button to switch to Clock Mode"
    >
      Set Clock Mode 1
    </button>
    <button
      type="button"
      onclick="triggerRxTxCmd('e102')"
      title="Click this button to switch to Clock Mode"
    >
      Set Clock Mode 2
    </button>
    <button type="button" onclick="clearScreen('00')">
      Clear Screen (All Black)
    </button>
    <button type="button" onclick="clearScreen('ff')">
      Clear Screen (All White)
    </button>
    <button type="button" onclick="triggerEpdCmd('0101')">
      Refresh Screen (Image Mode, Full Update)
    </button>
    <button type="button" onclick="triggerEpdCmd('0100')">
      Refresh Screen (Image Mode, Partial Update)
    </button>
    <br /><br />

    <h3>Upload image to display</h3>
    <input
      type="file"
      id="image_file"
      onchange="update_image()"
      accept=".png,.jpg,.bmp,.webp"
    />
    Dithering:
    <select id="dithering" title="Dithering algorithm">
      <optgroup label="BW">
        <option value="bw_FloydSteinberg">FloydSteinberg</option>
        <option value="bw_FalseFloydSteinberg">FalseFloydSteinberg</option>
        <option value="bw_Stucki">Stucki</option>
        <option value="bw_Atkinson">Atkinson</option>
        <option value="bw_Jarvis">Jarvis</option>
        <option value="bw_Burkes">Burkes</option>
        <option value="bw_Sierra">Sierra</option>
        <option value="bw_TwoSierra">TwoSierra</option>
        <option value="bw_SierraLite">SierraLite</option>
      </optgroup>
      <optgroup label="BWR">
        <option value="bwr_FloydSteinberg">FloydSteinberg</option>
        <option value="bwr_FalseFloydSteinberg">FalseFloydSteinberg</option>
        <option value="bwr_Stucki">Stucki</option>
        <option value="bwr_Atkinson">Atkinson</option>
        <option value="bwr_Jarvis">Jarvis</option>
        <option value="bwr_Burkes">Burkes</option>
        <option value="bwr_Sierra">Sierra</option>
        <option value="bwr_TwoSierra">TwoSierra</option>
        <option value="bwr_SierraLite">SierraLite</option>
      </optgroup>
    </select>
    <label style="margin-left: 8px">
      <input type="checkbox" id="dithSerp" /> Serpentine
    </label>
    Threshold:
    <input type="number" max="255" min="0" value="125" id="threshold" />
    <button onclick="update_image()">Reload Image</button>
    <br />

    <div id="canvas-box">
      <div id="tool-box">
        Mode:
        <select id="canvas-mode">
          <option value="paint">Brush</option>
          <option value="font" title="After typing, click: Save Text Box">
            Text
          </option>
        </select>
        Brush/Text Size:
        <input
          type="number"
          max="13"
          min="1"
          step="1"
          value="3"
          id="paint-size"
        />
        Color:
        <select id="paint-color">
          <option value="red">Red</option>
          <option value="white">White</option>
          <option value="black">Black</option>
        </select>
        <button id="update-text" style="display: none">Save Text Box</button>
        <button onclick="clear_canvas()">Clear Canvas</button>
      </div>
      <input
        id="edit-font"
        style="
          max-width: 250px;
          position: absolute;
          border: black solid 1px;
          background-color: rgba(0, 0, 0, 0);
          display: none;
          overflow: auto;
        "
      />
      <canvas
        id="canvas"
        width="250"
        height="128"
        style="border: black solid 1px"
      ></canvas>
      <br />
      <button onclick="upload_image()" style="font-weight: bold">
        Upload to Display Now
      </button>
      <br />
    </div>

    <br />
    <h3>Set Time</h3>
    <button id="time-setter" onclick="setTime()">Set time to:</button> <br />
    Offset +<input
      type="number"
      max="24"
      min="0"
      id="hour-offset"
      value="0"
      style="width: 40px"
    />
    hours

    <div id="tab_image">
      <br />
      <h3>Display Control</h3>
      <input type="file" />
      <button type="button" onclick="upload_epd_buffer();">
        Upload image to display buffer
      </button>
      <br />
      <textarea id="buffer" rows="10" cols="90"></textarea><br />
      <br />
    </div>

    <div
      id="log-box"
      style="
        position: absolute;
        right: 10px;
        top: 0px;
        width: 500px;
        height: 50%;
      "
    >
      Log:
      <br />
      <div
        id="log"
        style="
          width: 100%;
          height: 100%;
          overflow: scroll;
          border: solid 1px;
          padding: 20px;
        "
      ></div>
    </div>
  </body>
</html>
